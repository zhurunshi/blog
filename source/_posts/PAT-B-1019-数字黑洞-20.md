---
title: PAT-B 1019. 数字黑洞 (20)
categories: PAT-B
date: 2016-09-25 00:39:38
tags:
---
# 传送门
[https://www.patest.cn/contests/pat-b-practise/1019](https://www.patest.cn/contests/pat-b-practise/1019)
<!--more-->
# 题目
> 给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
**输入格式：**
输入给出一个(0, 10000)区间内的正整数N。
**输出格式：**
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。
**输入样例1：**6767
**输出样例1：**
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
**输入样例2：**
2222
**输出样例2：**
2222 - 2222 = 0000

# 分析
在这道题中学习到了头文件algorithm中的sort函数，同时也使用了简单的compare方法。
思路大概是：
1.先判断输入的数是否是1111的倍数，如果是，就打印结果并返回零值结束程序；
2.将数值转换成char数组，然后利用sort函数配合compare方法对char数组进行排序，这里也可以使用vector的sort配合reverse反转数组使用，也是很方便的，然后输出结果，遇到6174就停止即可，这里需要注意的是一定要将6174的判断写在最后，因为输入6174的时候，还是需要输出一行结果再停止程序的。

遇到的坑：
1.之前对题目的输入一直以为是4位数，但是看过题干后才知道输入是0-10000区间内的正整数，也就是说要对正整数进行处理，在不足4位整数前补0；
2.char c[4]={'0','0','0','0'};然后println("%s", c);总是出错，问了下朋友才知道，原来要再最后加字符串结束符，即char[5]={'0','0','0','0','\0'}，之前打印出来总是“烫烫烫烫”。我去，要不要这么烫？

最后科普一下：
1.“烫烫烫”和“屯屯屯”产生自VC，这是debug模式下VC对内存的初始化操作。VC会把栈中新分配的内存初始化为0xcc，而把堆中新分配的内存初始化为0xcd。把0xcc和0xcd按照字符打印出来，就是烫和屯了。
2.“锟斤拷”，这个是字符编码造成的。在进行从GBK到unicode的转换过程中，部分字符不能转化，于是unicode给了它们一个特殊的占位符U+FFFD，这个用UTF-8表示就成了\xef\xbf\xbd。如果出现两个连着的\xef\xbf\xbd\xef\xbf\xbd，按照两个字节一个字显示成汉字，就成了锟斤拷这三个字。
3.“锘”，这个也是由于微软的字符编码造成的，用微软的记事本打开并保存成UTF-8的时候会在前面加上UTF-8文件的Unicode签名BOM(Byte Order Mark)，在JSP和PHP开发中经常遇到，微软在自己的UTF-8格式的文本文件之前加上了EF BB BF三个字节，其他文本编辑器会识别此类文件为UTF-8+文件，然而这个只是微软暗自作的标记, 其它平台上并没有对UTF-8文本文件做个这样的标记。在文本编辑器中点击保存记得选UTF-8 NO BOM就好了。

来首诗作结：
手持两把锟斤拷，口中疾呼烫烫烫。
脚踏千朵屯屯屯，笑看万物锘锘锘。
# 源代码

	//C/C++实现
	#include <iostream>
	#include <algorithm>

	using namespace std;

	int compare(const int &a, const int &b){
		return a>b;
	}

	int main(){
		int n;
		scanf("%d", &n);
		if(n % 1111 == 0){
			printf("%d - %d = 0000\n", n, n);
			return 0;
		}
		else{
			int tmp = n;
			while(true){
				char c[5] = {'0','0','0','0','\0'};
				int a, b;
				for(int i = 3; tmp != 0; i--){
					c[i] = (tmp % 10) + 48;
					tmp /= 10;
				}
				sort(c, c + 4, compare);
				a = (c[0] - 48) * 1000 + (c[1] - 48) * 100 + (c[2] - 48) * 10 + (c[3] - 48);
				printf("%s - ", c);
				sort(c, c + 4);
				b = (c[0] - 48) * 1000 + (c[1] - 48) * 100 + (c[2] - 48) * 10 + (c[3] - 48);
				printf("%s = ", c);
				tmp = a - b;
				printf("%04d\n", tmp);
				if(tmp == 6174){
					break;
				}
			}
		}
		return 0;
	}