---
title: PAT-B 1065. 单身狗(25)
categories: PAT-B
date: 2016-12-22 15:17:25
tags:
---
# 传送门
[https://www.patest.cn/contests/pat-b-practise/1065](https://www.patest.cn/contests/pat-b-practise/1065)
<!--more-->
# 题目
> “单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。
**输入格式：**
输入第一行给出一个正整数N（<=50000），是已知夫妻/伴侣的对数；随后N行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（<=10000），为参加派对的总人数；随后一行给出这M位客人的ID，以空格分隔。题目保证无人重婚或脚踩两条船。
**输出格式：**
首先第一行输出落单客人的总人数；随后第二行按ID递增顺序列出落单的客人。ID间用1个空格分隔，行的首尾不得有多余空格。
**输入样例：**
3
11111 22222
33333 44444
55555 66666
7
55555 44444 10000 88888 22222 11111 23333
**输出样例：**
5
10000 23333 44444 55555 88888

# 分析
真是一道恶趣味的题，不过作为最后一道，难度倒是不大。
1.建立一个伴侣表，用每个人ID作为索引，在其索引下，存放夫妻/伴侣的ID；
举例来讲，若11111和22222互为伴侣，则table[11111]=22222，table[22222]=11111。
2.先把所有参加排队的宾客ID存到数组里面；
3.遍历宾客数组，查找对应伴侣表里面的伴侣是否能在宾客的数组找到，如果找不到，说明是单身狗，将其加入到单身狗的数组里面；
4.遍历宾客数组完成后，对单身狗数组排序（升序）；
5.遍历输出单身狗数组。

注意：ID不足五位的，要用0补位，就这一个坑。

**对了，还有，末尾不要输出一个换行符，容易有错。**
强迫症是病，得治。

# 源代码

	//C/C++实现
	#include <iostream>
	#include <vector>
	#include <algorithm>

	using namespace std;

	int table[100000];

	int main(){
		int n;
		scanf("%d", &n);
		int a, b;
		for(int i = 0; i < n; ++i){
			scanf("%d %d", &a, &b);
			//建立相互映射关系 
			table[a] = b;
			table[b] = a;
		}
		scanf("%d", &n);
		vector<int> v(n);
		vector<int> doge;
		for(int i = 0; i < n; ++i){
			scanf("%d", &v[i]);
		}
		for(int i = 0; i < n; ++i){
			vector<int>::iterator result = find(v.begin(), v.end(), table[v[i]]);
			if(result == v.end()){ //说明没找到他/她的伴侣 
				doge.push_back(v[i]); //单身狗的队伍又壮大了 
			}
		}
		sort(doge.begin(),doge.end());
		printf("%d\n", doge.size());
		for(int i = 0; i < doge.size(); ++i){
			if(i == 0){
				printf("%05d", doge[i]);
			}		
			else{
				printf(" %05d", doge[i]);
			}
		}
	//	printf("\n");
	}