---
title: Java知识点总结
categories: Java
date: 2016-10-31 22:10:02
tags:
---
#### equals和==的区别
1.基本数据类型（byte short char int long float double boolean）
他们之间的比较应该用双等号，比较的是他们的值。
2.复合数据类型
当他们用==比较的时候，比较的是他们在内存中的地址，所以，除非是同一个对象，比较为true，否则比较后结果为false。
但是有些常用的数据类型比如String重写了equals方法，所以可以用equals来比较值，但是如果没重写equals方法的话仍旧是比较他们在内存中的地址。
注：==就是调用了对象的equals语句，在未重写equals方法的类中，二者的表现是一致的。
在重写equals方法的类中，二者的表现分别为：
equals() 比较的是两个对象的值是否相同。
==比较的是两个对象的引用（内存地址）是否相同，也用来比较两个基本数据类型的变量值是否相等。
***
#### Java语言的跨平台特性
Java的跨平台性是指，编译后的Java程序可直接在不同平台上运行而不用重新编译，实际上编译后的Java代码并不是传统的二进制代码（如Windows下的.exe文件），而是Java字节码，这种字节码文件是不能直接在操作系统上执行的。必须要有一个中间环节负责将Java字节码解释成二进制码，这个中间环节就是Java虚拟机（JVM），由于目前大多数操作系统已经实现了JVM，所以Java轻松实现跨平台性，即：一次编译，到处运行。
***
#### Class类加载到虚拟机的过程（类的生命周期）
加载，验证，准备，解析，初始化，使用，卸载。验证+准备+解析统称为连接。
加载：
1.通过类的全限定名来获取定义此类的二进制流
2.将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构
3.在Java堆中生成一个代表这个类的Java.lang.Class对象，作为方法区的这些数据的访问入口
验证：不同虚拟机会进行不同类验证的实现，但大致都会完成以下四种验证
1.文件格式验证（验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理）
2.元数据验证（对字节码描述信息进行语义分析，保证其描述信息符合java语言规范）
3.字节码验证（对类方法体进行数据流和控制流分析，保证类的方法在运行时不会做出危害虚拟机的行为）
4.符合引用验证（发生在将符号引用转化为直接引用的时候，在解析阶段中发生）
准备：
正式为类成员变量分配内存并设置初始值，内存在方法区中分配，这里的初始值是0而不是用户指定的值。
解析：
虚拟机将常量池内的符号引用替换为直接引用的过程。主要针对类或接口、字段、类方法、接口方法四类符号引用进行。
初始化：
真正开始执行类中定义的Java程序代码，是执行类构造器<clinit>()方法的过程。
<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，<clinit>()方法对于类或接口来说不是必须的，如果类中没有静态语句块，也没有对变量的赋值操作，则编译器可以不为这个类生成<clinit>()方法。
***
#### 进一步理解类加载器（ClassLoader）
类加载器可划分为以下三类系统提供的类加载器：
1.启动类加载器（Bootstrap ClassLoader）
负责将存放在<JAVA_HOME>\lib目录中的类库加载到虚拟机内存中，无法呗Java程序直接引用。
2.扩展类加载器（Extension ClassLoader）
负责加载<JAVA_HOME>\lib\ext目录中的类库，可被开发者直接使用。
3.应用程序类加载器
负责加载用户类路径ClassPath上指定的类库，可被开发者直接使用，且为默认的类加载器。
Java中采用双亲委派模型来实现类的加载模式。要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，此处的父子关系不以继承来实现，而是采用组合来利用父加载器。
双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只要父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会自己去加载，模型如下图所示：
![](http://upload-images.jianshu.io/upload_images/2319568-6dcf85ee63088b0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
***
#### SDK、JDK、JRE、JVM名词解释与联系
1.SDK
Software Develop Kit，软件开发工具包，各种不同类型的软件开发，都可以有自己的SDK。
2.JDK
而Java的SDK最早叫Java Software Develop Kit，后来改名叫JDK，即Java Develop Kit。
JDK作为Java开发工具包，主要用于构建在Java平台上运行的应用程序、Applet和组件等。
3.JRE
Java Runtime Environment，Java运行环境，也就是Java平台。所有的Java程序都要在JRE下才能运行，JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以，在JDK的安装目录下有一个名为JRE的目录，用于存放JRE文件。
4.JVM
Java Virtual Machine，Java虚拟机，是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行，使用JVM就是为了实现跨平台。
***
#### 列举Java语言的主要特点
1.简单：Java的语法与C++很接近，另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载，多继承，自动的强制类型转换。特别是Java不使用指针，并提供了自动的废料收集，使程序员不必为内存管理而担忧。
2.面向对象：Java提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制。Java是纯的面向对象的语言。
3.健壮性：Java的强类型机制、异常处理、废料的自动收集等是Java健壮性的重要保证。对指针的丢弃也是Java的明智选择。
4.安全性：由于Java取消了指针，有效提高了程序的安全性；再一个，Java程序运行在JVM上，JVM可以有效过滤掉恶意代码，防止程序员有意编写病毒程序。
5.分布性/跨平台：因为JVM的存在，所以可以跨平台，跨操作系统
6.多线程：Java支持多个线程的同时执行，并提供多线程之间的同步机制。
***
#### Java中的内存分配
1.Java中的原始数据类型都是在栈中分配空间
2.除了8种原始数据类型外，其他数据类型（数据、对象）只能到堆中开辟空间，而在堆中分配的空间又只能通过指针访问
3.通过指针访问堆内存的方式，在Java中被称作引用数据类型
4.可以认为，Java中的引用就类似于C中的指针，只是做了封装，避免因直接操作指针而造成的数据破坏。
***
#### 按位与（&）/或（|）/异或（^）
写在最前：
正数的原码反码补码相同，负数的原码首位是符合位为1，反码是将原码的符号位不变，其他位按位取反，补码是将原码的符号位不变，其他位按位取反，再加1。
1.按位与
两位同时为1，结果才为1，否则为0
注意：负数按补码形式参加按位与运算
2.按位或
两位同时为0，结果才为0，否则为1
注意：负数按补码形式参加按位或运算
3.按位异或
两位相同时为1，不同时为0
注意：负数按补码形式参加按位异或运算
***
#### 左移运算符（<<）、右移运算符（>>）和无符号右移运算符（>>>）
1.左移运算符
将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）
注意：若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘2
2.右移运算符
将一个运算对象的各二进制位全部右移若干位，正数左补0，负数左补1，右边舍弃
操作数每右移一位，相当于该数除以2
3.无符号右移运算符
将一个运算对象的各二进制位全部右移若干位，不管正负，始终左补0
***
#### 面向对象的三大原则
1.封装：将某些东西包装在一起，然后以新的完整形式呈现出来，封装其实就是有选择地公开或隐藏某些信息，解决了数据的安全性问题。
2.继承：继承就是重用现有的类来生成新类的一种特征，解决了代码的重用问题。
3.多态：多态是指同一函数在不同的类中有不同的实现，解决了程序的扩展问题。
***
#### 访问修饰符
1.public：本类和非本类均可随意访问
2.protected：本类及其子类可以访问（父子友好），同一个包中的其他类也可访问（包内友好）
3.缺省：只有相同包中的类可以访问（包内友好）
4.private：只有本类可以访问
***
#### 构造方法的执行顺序
1.当实例化子类的对象时，必须先执行父类的构造方法，然后再执行子类的构造方法。
2.如果父类的构造方法执行失败，那么子类的对象也将无法实例化。
***
#### Super的两种用法
1.在子类的构造方法中，super关键字可以显式地调用父类的构造方法，用于将参数传递给他。
用法：super(实际参数)
注意：该语句必须是子类构造方法的第一条语句。
2.用于父类和子类有同名成员时，从子类访问父类成员并给它赋值。因为在子类中默认访问是属于子类的成员，super关键字可以明确地指定要访问父类的成员。
用法：super.成员名 = 值
前提条件：父类中该成员不是private的
***
#### 静态多态和动态多态
1.静态多态：静态多态也称为编译时多态，即在编译时决定调用哪个方法。
静态多态一般是指方法重载。只要构成了方法重载，就可以认为形成了静态多态的条件。
注意：静态多态与是否发生继承没有必然联系。
2.动态多态：动态多态也称为运行时多态，即在运行才能确定调用哪个方法。
要具备的条件：
- 必须要有继承的情况存在
- 在继承中必须要有方法覆盖
- 必须由基类的引用指向派生类的实例，并且通过基类的引用调用被覆盖的方法
***
#### 抽象类
- 如果抽象类的派生子类没有实现其中的所有抽象方法，那么该派生子类仍然是抽象类，只能用于继承，而不能实例化
- 抽象类中也可以包含有非抽象的方法
- 抽象类可以没有抽象方法，但是如果一个类声明为抽象类，即使没有抽象方法，也不能实例化
- 如果类中有了一个抽象方法，那么必须声明为抽象类，否则编译不通过
- 构造方法和static方法不可以修饰为abstract
***
#### 接口
- 接口中不能定义非抽象的方法
- 接口中的所有方法都默认为抽象方法，无需在每个方法前加abstract
- 接口的实现类应该提供对接口中所有抽象方法的具体实现，否则将成为抽象类
- 可以使用接口的引用，从而实现多态
- 可以由父接口派生出子接口
***
#### final关键字
有三种用法：分别应用于变量、成员方法、类
1.变量：如果将某个变量修饰为final，那么该变量就成为常量
注意：常量在声明时必须初始化
例如：

    final int i = 1

2.成员方法：如果将某个成员方法修饰为final，则意味着该方法不能被子类覆盖，若在子类中出现同原型的方法，将会报错
例如：

    public final void fun() {...}

3.类：如果将某个类修饰为final，则说明该类无法被继承
例如：

    public final class 类名

***
#### 异常
异常分为两大类：编译时异常和运行时异常

    try{
        //监视有可能发生异常的代码段 
    }catch(异常类型){ //捕获发生的异常
        //对异常进行处理 
    }

异常说明Exception异常层次结构的根类RuntimeException许多java.lang异常的基类ArithmeticException算术异常，如：除数为0IllegalArgumentException方法接收到非法参数ArrayIndexOutOfBoundsException数组下标越界NullPointerException访问空引用ClassNotFoundException不能加载所需的类NumberFormatException字符串转换数字失败IOExceptionI/O异常的根类FileNotFoundException找不到文件EOFException文件结束
finally块：
- 无论try/catch块中发生了什么，finally块都一定会执行
- 当异常发生时，程序可能会意外中断，有些被占用的资源得不到清理。finally块可以确保执行所有的清理工作
- 无论是否发生异常，finally块都将执行
- finally块是可选的，可视具体情况决定是否添加
- finally块必须和try块一起使用，不能单独存在

多重catch块：
有时候，在try块中的代码段将有可能产生多种不同类型的异常，需要用多重catch块，来分别捕获不同类型的异常。
注意：
1.多重catch块只会捕捉到最先产生的异常，而不是把所有的异常全部捕捉完。即：不论有多少个catch块，最多只会执行其中的一个。
2.所以请注意catch块的书写顺序，类层次越低的越往上写，越高的越往下写。
throw关键字 && throws关键字
1.throw是语句抛出异常；throws是方法抛出异常
2.throws可以单独使用；throw不能
3.throw要么和try-catch[-finally]语句配套使用，要么和throws配套使用。但是throws可以单独使用。throws E1,E2,E3 只是告诉程序这个方法可能会抛出这些个异常，方法的调用者可能要处理这些异常。且必须对调用该方法的地方做try-catch处理；而throw是明确这个地方要抛出这个异常。
***
#### Java对于Integer与int的自动装箱与拆箱的设计
为了加大对简单数字的重利用，Java定义：在自动装箱时对于值从-128到127之间的值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象，而如果超过了从-128到127之间的值，被装箱后的Integer对象并不会被重用，即：相当于每次装箱时都新建一个Integer对象。
以上的现象是由于使用了自动装箱所引起的，如果没有使用自动装箱，而用new来进行实例化，就会每次new一个新对象。
***
#### java.lang包
1.Data类和Calender类用来操作日期和时间
2.可以使用Random类的对象来生成随机数
3.集合框架提供了一系列复杂的数据结构和优越的算法
4.ArrayList类可以创建动态数组
5.LinkedList类可以创建链表结构
6.Vector类可以创建线程同步的动态数组
7.HashMap类可以创建键值对集合
***
#### JDBC程序访问数据库步骤
1.导出java.sql包
2.选择方式：一般用纯Java驱动方式，速度快
3.加载并注册驱动程序
4.创建Connection对象
5.创建Statement对象
6.执行SQL语句
7.使用ResultSet对象
8.关闭ResultSet对象
9.关闭Statement对象
10.关闭Connection对象
先打开的对象先关闭。
***
#### Java GUI编程
JFrame组件用于在Swing程序中创建窗体。一个完整的窗体是由外部框架和内容面板两部分组成的。
外部框架是指由标题栏和四边所组成的空心边框（JFrame），它主要用来控制窗体的大小和外观；我们实际操作的是内容面板，如设置窗体的背景色，设置窗体的布局，往窗体中添加其他组件等等；使用
getContentPane方法获得当前窗体的内容面板，该方法的返回值是Container（容器）类对象，
如：

    Container contentPane = getContentPane();

Container类在java.awt包中。
JButton - 按钮
JLabel - 标签（既可以显示文本，也可以显示图像）
JTextField - 文本框组件（接收用户的输入）
JPanel - 面板组件（可以添加其它组件，布局嵌套，类似Container）
事件处理步骤：
1.确定事件源及监听器类型，如：点击事件 - ActionListener
2.实现监听器接口，并重写其中的抽象方法，一般采用内部类
例如：

    class MyListener implements ActionListener{
    public void actionPerformed(ActionEvent ae){
        ......
        }
    }

3.为事件源注册监听器
例如：

    [控件名].addActionListener(new MyListener());

常用监听器：
1.ActionListener - 鼠标点击某个按钮时会产生该事件
2.KeyListener - 键盘事件
3.MouseListener - 用来处理鼠标的动作
4.MouseMotionListener - 专门处理鼠标运动事件
5.ItemListener - 下拉列表、单选按钮、复选按钮这些有选项的组件，当它们的选项发成改变的时候，都会产生选项事件
6.WindowListener - 操作窗口时会产生窗口事件
7.FocusListener - 某个组件得到/丢失焦点时将产生焦点事件
***