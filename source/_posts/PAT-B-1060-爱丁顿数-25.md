---
title: PAT-B 1060. 爱丁顿数(25)
categories: PAT-B
date: 2016-11-05 22:01:34
tags:
---
# 传送门
[https://www.patest.cn/contests/pat-b-practise/1060](https://www.patest.cn/contests/pat-b-practise/1060)
<!--more-->
# 题目
> 英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数”E，即满足有E天骑车超过E英里的最大整数E。据说爱丁顿自己的E等于87。
现给定某人N天的骑车距离，请你算出对应的爱丁顿数E（<=N）。
**输入格式：**
输入第一行给出一个正整数N（<=10^5），即连续骑车的天数；第二行给出N个非负整数，代表每天的骑车距离。
**输出格式：**
在一行中给出N天的爱丁顿数。
**输入样例：**
10
6 7 6 9 3 10 8 2 7 8
**输出样例：**
6

# 分析
这道题想了好久才用暴力法过了部分测试点，最后还是差一个测试点没法通过，应该是用来卡暴力法的，起初题意本身都理解不清楚（智商捉急）。
这里简单“翻译”一下：如果E天的骑车公里数均>天数E，那么这个E符合条件，现在可以有很多个E都符合这个条件，求符合条件的最大值E。
注意：如果输入3 1 2 3。那么结果是1。因为大于1的天数是2天，大于2的天数是1天，大于3的天数是0天，所以只有E=1满足E天骑车超过E英里，多余的天数可以不算，只要天数>=E即可，不非得是等于。另外在没有符合条件的值是要输出0。
具体的算法是对数组进行降序排序，降序排列的好处是可以直接计算出最大E值。
首先根据样例降序后为：10 9 8 8 7 7 6 6 3 2
1.用10和10的下标1比较，10 > 1，所以有1天的骑车超过1英里；
2.用9和9的下标2比较，9 > 2，所以有2天的骑车超过2英里（因为10 > 9，9符合，所以10肯定符合，后面同理）；
3.用8和8的下标3比较，8 > 3，所以有3天的骑车超过3英里；
4.用8和8的下标4比较，8 > 4，所以有4天的骑车超过4英里；
5.用7和7的下标5比较，7 > 5，所以有5天的骑车超过5英里；
6.用7和7的下标6比较，7 > 6，所以有6天的骑车超过6英里；
7.用6和6的下标7比较，6 > 7不成立，所以最大值E为6。
这里需要注意的是，若全部满足这个条件的话，要检测遍历到数组的结尾就停止，不能越界。

# 源代码

	//C/C++实现
	#include <iostream>
	#include <vector>
	#include <algorithm>

	using namespace std;

	bool compare(int a, int b){
		return a > b;
	}

	int main(){
		int n;
		scanf("%d", &n);
		vector<int> v(n + 1);
		for(int i = 1; i <= n; ++i){
			scanf("%d", &v[i]);
		}
		sort(v.begin() + 1, v.end(), compare); //desc
		int e = 0;
		int i = 1;
		while(i <= n && v[i] > i){
			++e;
			++i;
		}
		printf("%d\n", e);
		return 0;
	}